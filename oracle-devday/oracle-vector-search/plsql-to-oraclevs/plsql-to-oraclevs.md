# PL/SQL기반으로 RAG 구성하기

## Introduction

Oracle AI Database 26ai Vector Search에서는 Vector Store로서의 기능 외에, 문서 로딩, 문서 분할, 임베딩 등 다른 기능도 PL/SQL 패키지로 제공하고 있습니다. 다른 개발 프레임워크를 사용하지 않고, PL/SQL을 사용하고, Oracle AI Database 26ai로 RAG를 구성하는 방법을 알아 봅니다.


Oracle AI Vector Search User's Guide 가이드의 [Vector Search PL/SQL Packages](https://docs.oracle.com/en/database/oracle/oracle-database/26/vecse/vector-search-pl-sql-packages-node.html) 항목에서 제공하는 패키지는 다음 세가지입니다.

- `DBMS_VECTOR`

    `DBMS_VECTOR` 패키지는 사용자 데이터로부터 청크(chunk) 또는 임베딩을 추출하고, 프롬프트나 이미지를 기반으로 텍스트를 생성하며, 벡터 인덱스를 생성하거나 인덱스 정확도를 보고하는 등 Oracle AI Vector Search에서 자주 수행하는 작업을 간소화해줍니다.

- `DBMS_VECTOR_CHAIN`

    `DBMS_VECTOR_CHAIN` 패키지는 Oracle AI Vector Search에서 고급 작업을 수행할 수 있게 해줍니다. 예를 들어, 데이터 청킹(chucking) 및 임베딩뿐 아니라 텍스트 생성 및 요약 기능을 제공하며, 이를 하나의 파이프라인으로 연결해 엔드 투 엔드 검색에 적합한 유사도 검색 및 하이브리드 검색을 지원합니다.

- `DBMS_HYBRID_VECTOR`

    `DBMS_HYBRID_VECTOR` 패키지는 SEARCH라는 JSON 기반 쿼리 API를 제공하여 하이브리드 벡터 인덱스를 대상으로 쿼리할 수 있게 해줍니다.

Autonomous AI Database Serverless 문서에서 Autonomous AI Database이 제공하고 있는 패키지의 하나로 [`DBMS_CLOUD_AI` Package](https://docs.oracle.com/en-us/iaas/autonomous-database-serverless/doc/dbms-cloud-ai-package.html)을 다음과 같이 설명하고 있습니다.

- `DBMS_CLOUD_AI`

    `DBMS_CLOUD_AI` 패키지는 Select AI와 함께, 자연어 프롬프트를 번역하여 SQL 문을 생성·실행·설명하도록 지원하고 설정할 수 있게 해줍니다. 또한, 검색 증강 생성(RAG)과 자연어 기반 상호작용(예: LLM과의 대화) 기능도 제공합니다.

실습 예상 시간: 10분

### Objectives

이 실습에서는 다음을 수행합니다:

* PL/SQL에서 Oracle AI Database 26ai을 Vector Store로 사용하는 것을 물론 Oracle AI Vector Search에서 제공하는 PL/SQL 패키지를 사용하여, RAG 구현하는 과정을 단계적으로 실습합니다.

### 사전 준비 사항

* *Lab2를 반드시 완료할 것*

## Task 1: 필요한 테이블 생성

1. 테이블이 이미 있는 경우 삭제합니다.

    ```shell
    <copy>
    drop table if exists vector_store;
    drop table if exists document_store;
    </copy>
    ```

2. 문서파일을 로드해서 BLOB 형태로 저장할 테이블을 생성합니다.

    ```shell
    <copy>
    create table if not exists document_store (
        id           integer generated by default on null as identity (start with 1 nocache) primary key,
        file_name    varchar2(900),
        file_size    integer,
        file_type    varchar2(100),
        file_content blob
    );
    </copy>
    ```

3. 로드한 문서를 text chunk 및 해당하는 vector embedding로 저장할 테이블을 생성합니다.

    ```shell
    <copy>
    create table if not exists vector_store (    
        doc_id       number(*,0) not null enable, 
        embed_id     number,
        embed_data   varchar2(4000),
        embed_vector vector,
        foreign key (doc_id) references document_store(id)
    );
    </copy>
    ```

## Task 2: 문서 로드

1. 현재 Object Storage의 Public Bucket에 미리 올려둔 문서를 다운로드 받습니다.

    ```
    <copy>    
    begin
        dbms_cloud.delete_file('AI_ASSETS_DIR', 'customer-stories_stories-from-oracle-cloud-v3.pdf', force => true);
        dbms_cloud.delete_file('AI_ASSETS_DIR', 'database-release-notes.pdf', force => true);    

        dbms_cloud.get_object(
            object_uri      => 'https://objectstorage.us-chicago-1.oraclecloud.com/n/apackrsct01/b/oravs-bucket/o/customer-stories_stories-from-oracle-cloud-v3.pdf',
            directory_name  => 'AI_ASSETS_DIR'
        );

        dbms_cloud.get_object(
            object_uri      => 'https://objectstorage.us-chicago-1.oraclecloud.com/n/apackrsct01/b/oravs-bucket/o/database-release-notes.pdf',
            directory_name  => 'AI_ASSETS_DIR'
        );    
    end;
    /
    </copy>    
    ```

2. 다운로드된 파일들을 확인합니다.

    ```
    <copy>    
    select * from dbms_cloud.list_files('AI_ASSETS_DIR'); 
    </copy>    
    ```

3. 문서를 생성한 테이블로 로드합니다.

    ```shell
    <copy>
    insert into document_store (
        file_name,
        file_size,
        file_type,
        file_content
    ) values (
        'database-release-notes.pdf',
        dbms_lob.getlength(to_blob(bfilename('AI_ASSETS_DIR', 'database-release-notes.pdf'))),
        'PDF',
        to_blob(bfilename('AI_ASSETS_DIR', 'database-release-notes.pdf'))
    );
    insert into document_store (
        file_name,
        file_size,
        file_type,
        file_content
    ) values (
        'customer-stories_stories-from-oracle-cloud-v3.pdf',
        dbms_lob.getlength(to_blob(bfilename('AI_ASSETS_DIR', 'customer-stories_stories-from-oracle-cloud-v3.pdf'))),
        'PDF',
        to_blob(bfilename('AI_ASSETS_DIR', 'customer-stories_stories-from-oracle-cloud-v3.pdf'))
    );
    </copy>
    ```

2. 결과를 확인합니다.

    ```shell
    <copy>    
    select * from document_store; 
    </copy>    
    ```

## Task 3: 문서 변환

**문서에서 텍스트를 추출**

1. `dbms_vector_chain.utl_to_text()` 프로시저를 이용해서 BLOB 문서에서 텍스트를 추출해 봅니다.

    ```shell
    <copy>    
    select id, substr(dbms_vector_chain.utl_to_text(ds.file_content), 1, 100) as result
    from document_store ds;
    </copy>    
    ```

2. 추출된 텍스트에, 중첩된 공백을 줄이고, 줄바꿈(라인피드)를 다음과 같이 함수를 이용해 제거할 수 있습니다. 이전 결과와 비교해 봅니다.

    ```shell
    <copy>    
    select id, substr(REGEXP_REPLACE(replace(trim(dbms_vector_chain.utl_to_text(ds.file_content)), chr(10), ' '), ' +', ' '), 1, 100) as result
    from document_store ds;   
    </copy>     
    ```

**전체 텍스트를 Chunk로 분할**

1. `dbms_vector_chain.utl_to_chunks()` 프로시저를 사용하여, 추출 및 변환한 문서를 다시 여러개의 청크로 분할합니다.

    ```shell
    <copy>    
    select ct.*
      from document_store ds,
           dbms_vector_chain.utl_to_chunks(
               REGEXP_REPLACE(
                   replace(trim(dbms_vector_chain.utl_to_text(ds.file_content)), chr(10), ' '),
                   ' +', 
                   ' '
               )
           ) ct;
    </copy>           
    ```

2. JSON 형식으로 반환됩니다. json_table 함수를 사용하면, 테이블 형식으로 조회할 수 있습니다.

    ```shell
    <copy>    
    select ct.*
    from document_store ds,
        dbms_vector_chain.utl_to_chunks(
            REGEXP_REPLACE(replace(trim(dbms_vector_chain.utl_to_text(ds.file_content)), chr(10), ' '), ' +', ' ')
        ) t,
        json_table(
                t.column_value, 
                '$[*]' columns (
                    chunk_id     number         path '$.chunk_id',
                    chunk_offset number         path '$.chunk_offset',
                    chunk_length number         path '$.chunk_length',
                    chunk_data   varchar2(4000) path '$.chunk_data'
                )
            ) as ct;
    </copy>            
    ```

3. `dbms_vector_chain.utl_to_chunks(DATA, PARAMS)`은 JSON 형식으로 파라미터를 지정할 수 있습니다. 아래 예시처럼 설정할 수 있습니다.

    ```shell    
    JSON('{
        "by"           :    "vocabulary",
        "max"          :    "100",
        "overlap"      :    "0",
        "split"        :    "custom",
        "custom_list"  :    [ "<p>" , "<s>" ],
        "vocabulary"   :    "myvocab",    
        "language"     :    "american",
        "normalize"    :    "options",
        "norm_options" :    [ "whitespace" ] 
    }')
    ```

    - by: 텍스트를 어떻게 split 할지 설정. characters, words, vocabulary (default: words)
    - max: 각 chunk의 최대 크기 (default: 200), by에서 지정한 단위기준
    - overlap: chunk 사이의 overlap 정도, %로 지정 (default: 0)
    - split: max size에 도달하였을 때 구체적으로 어떻게 split할지 지정함. (default: recursively)
    - language: 언어 (default: 세션의 NLS_LANGUAGE)
    - normalize: 전처리, 후처리 설정 (default: None)
    - 자세한 사항은 공식 문서 참조: [`UTL_TO_CHUNKS`](https://docs.oracle.com/en/database/oracle/oracle-database/26/vecse/utl_to_chunks-dbms_vector_chain.html)

4. 파라미터를 설정하여, 여러개의 청크로 분할합니다.

    ```shell
    <copy>    
    select ct.*
    from document_store ds,
        dbms_vector_chain.utl_to_chunks(
            REGEXP_REPLACE(replace(trim(dbms_vector_chain.utl_to_text(ds.file_content)), chr(10), ' '), ' +', ' '),
            json('{"max": 150, "split":"sentence", "language":"korean", "normalize":"all"}')
        ) t,
        json_table(
                t.column_value, 
                '$[*]' columns (
                    chunk_id     number         path '$.chunk_id',
                    chunk_offset number         path '$.chunk_offset',
                    chunk_length number         path '$.chunk_length',
                    chunk_data   varchar2(4000) path '$.chunk_data'
                )
            ) as ct;
    </copy>            
    ```

## Task 4: 내장 Embedding 모델

이전 실습에서 설명한 것처럼 REST 기반 외부 호출을 통해 외부 Embedding 모델을 사용하거나, ONNX 포맷을 임포트하여, 내장 Embedding 모델을 사용할 수 있습니다. 여기서는 내장 Embedding 모델을 사용합니다.
- [Generate Embeddings](https://docs.oracle.com/en/database/oracle/oracle-database/26/vecse/generate-embeddings.html)

1. 앞선 Lab2에서 이미 실습할 내용을 기준으로 현재 임포트된 내장 Embedding 모델을 조회합니다.

    ```shell
    <copy>    
    SELECT model_name, algorithm, mining_function FROM user_mining_models;
    </copy>    
    ```

2. Embedding을 테스트합니다.

    ```shell
    <copy>    
    SELECT VECTOR_EMBEDDING(MULTILINGUAL_E5_SMALL USING 'hello' as data);
    </copy>    
    ```

## Task 5: `DBMS_VECTOR_CHAIN` 연쇄호출을 통해 벡터화해 테이블에 저장

1. 개별 테스트를 다 했습니다. 이제 `utl_to_text` -> `utl_to_chunks` -> `utl_to_embeddings` 순서대로 연결되게 호출하여, 청크단위로 Vector Embedding 값과 함께 결과를 테이블에 저장합니다.

    ```shell
    <copy>    
    truncate table vector_store;

    insert into vector_store(doc_id, embed_id, embed_data, embed_vector)
    select ds.id, et.embed_id, et.text_chunk, et.embed_vector 
    from document_store ds,
        dbms_vector_chain.utl_to_embeddings(
            dbms_vector_chain.utl_to_chunks(
                REGEXP_REPLACE(replace(trim(dbms_vector_chain.utl_to_text(ds.file_content)), chr(10), ' '), ' +', ' '),
                json('{"max":"150","split":"sentence","language":"korean","normalize":"all"}')
            ),
            json('{"provider":"database", "model":"MULTILINGUAL_E5_SMALL"}')
        ) t,
        json_table(
            t.column_value, 
            '$[*]' columns (
                embed_id     number         path '$.embed_id',
                text_chunk   varchar2(4000) path '$.embed_data',
                embed_vector clob           path '$.embed_vector'
            )
        ) as et;

        commit;
    </copy>        
    ```
2. 결과를 확인합니다.

    ```shell
    <copy>    
    select count(*) from vector_store;

    select doc_id, embed_id, embed_data, embed_vector
    from vector_store 
    where rownum <= 3;
    </copy>    
    ```

## Task 6: PL/SQL에서 RAG 구현

**Query Vector, 유사도 검색**

1. Query Vector를 만들고 Vector Search가 잘 되는지 Vector간 유사도 검색을 해봅니다.

    ```shell
    <copy>    
    VARIABLE query_vector CLOB;

    BEGIN
        SELECT VECTOR_EMBEDDING(MULTILINGUAL_E5_SMALL USING 'Autonomous database를 사용하는 고객 사례들을 간략히 정리해줘' as data)
        INTO :query_vector;
    END;
    /

    select embed_id, embed_data, vector_distance(embed_vector, :query_vector, COSINE) as distance
    from vector_store
    order by distance
    fetch first 10 rows only;
    </copy>    
    ```

**OCI GenAI LLM에 질문하기**

1. 이전 실습에서 만든 OCI Generative AI 서비스 호출 등 OCI 자원에 접근하기 위해 Credential을 확인합니다.

    ```
    <copy>    
    SELECT owner, credential_name, username
    FROM all_credentials
    ORDER BY owner, credential_name, username;
    </copy>    
    ```

2. OCI Gen AI 연동을 다음과 같이 테스트합니다.

    ```
    <copy>    
    DECLARE
        input CLOB;
        params CLOB;
        output CLOB;
    BEGIN
        input := 'Autonomous database를 사용하는 고객 사례들을 간략히 정리해줘?';
        params := '{
            "provider" : "ocigenai",
            "credential_name" : "OCI_CRED",
            "url" : "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/chat",
            "model" : "openai.gpt-oss-20b"
        }';

        output := DBMS_VECTOR_CHAIN.UTL_TO_GENERATE_TEXT(input, json(params));
        DBMS_OUTPUT.PUT_LINE(output);
        IF output IS NOT NULL THEN
            DBMS_LOB.FREETEMPORARY(output);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE(SQLERRM);
            DBMS_OUTPUT.PUT_LINE(SQLCODE);
    END;
    /
    </copy>    
    ```

3. 참고 사항

    GenerateText는 Release Notes에서 공지된 바와 같이 Deprecated 되었습니다. 여전히 문서 예시는 그대로입니다. 사용시 다음과 같은 오류가 발생하니, 참고하세요.
    - [Deprecated APIs in OCI Generative AI](https://docs.oracle.com/en-us/iaas/releasenotes/generative-ai/deprecate-api-05292025.htm)
    - [SQL RAG Example](https://docs.oracle.com/en/database/oracle/oracle-database/26/vecse/sql-rag-example.html)

        ```
        params := '{
            "provider" : "ocigenai",
            "credential_name" : "OCI_CRED",
            "url" : "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/generateText",
            "model" : "cohere.command-a-03-2025"
        }';
        ```
        
        실행결과

        ```
        ORA-20000: Oracle Text error:
        DRG-50857: oracle error in dbms_vector_chain.utl_to_generate_text
        ORA-20400: Request failed with status HTTP 400 - oci://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/generateText
        Error response - { "code": "400", "message": "cohere.command-a-03-2025 does not support TextGeneration" }
        -20000
        ```

**RAG를 OCI GenAI LLM에 질문하기**

1. 반복질문을 위해 편의상 다음과 같이 function은 생성합니다.

    ```
    <copy>    
    create or replace function generate_text_response(user_question varchar2) return clob
    is

        params_genai clob;
        search_query varchar2(4000);
        message_cursor sys_refcursor;
        messages clob;
        message_line varchar2(4000);
        output clob;

        user_question_vec vector;

    begin

        select to_vector(vector_embedding(MULTILINGUAL_E5_SMALL using user_question as data)) as embedding into user_question_vec;

        search_query := '
            select embed_data
                from vector_store
            order by vector_distance(embed_vector, :user_question_vec, COSINE)
            fetch first 4 rows only';

        OPEN message_cursor FOR search_query USING user_question_vec;

        messages := 'CONTEXTS:'||chr(10);
        LOOP
            FETCH message_cursor INTO message_line;
            EXIT WHEN message_cursor%NOTFOUND;

            messages := messages || message_line || chr(10);
        END LOOP;

        messages := messages || chr(10) || 'INSTRUCTIONS:' || chr(10);
        messages := messages || 'Give the answer based on the Context. You MUST give Korean Answer.' || chr(10);

        messages := messages || chr(10) || 'QUESTION:' || chr(10);
        messages := messages || user_question || chr(10);

        --messages := messages || '###Answer###' || chr(10);

        CLOSE message_cursor;

        params_genai := '
        {
            "provider":"ocigenai",
            "credential_name": "OCI_CRED",
            "url": "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/chat",
            "model": "openai.gpt-oss-20b"
        }';

        dbms_output.put_line(to_char(user_question_vec));
        dbms_output.put_line(messages);

        output := DBMS_VECTOR_CHAIN.UTL_TO_GENERATE_TEXT(messages, json(params_genai));

        dbms_output.put_line(output);

        return output;

    EXCEPTION
        WHEN OTHERS THEN
            RETURN SQLERRM || SQLCODE;
    END;
    /
    </copy>    
    ```

2. 다음과 같이 질문합니다.

    ```
    <copy>
    set serveroutput on
    set timing on
    select generate_text_response('Autonomous database를 사용하는 고객 사례들을 간략히 정리해줘') as response;
    </copy>    
    ```

3. `dbms_output.put_line`의 출력결과는 위 명령을 실행하면, SCRIPT OUTPUT에서 확인할 수 있습니다.
